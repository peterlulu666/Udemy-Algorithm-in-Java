{"./":{"url":"./","title":"Introduction","keywords":"","body":"Algorithms in Java Algorithms in Java "},"Object Oriented Programming.html":{"url":"Object Oriented Programming.html","title":"Object Oriented Programming","keywords":"","body":"Object Oriented Programming "},"Intro to OOP Class  Object.html":{"url":"Intro to OOP Class  Object.html","title":"Intro to OOP Class  Object","keywords":"","body":"Intro to OOP Class Object Intro to OOP class object Java constructor Intro to OOP class object Earth.java package JavaOOPHuman; public class Earth { public static void main(String[] args) { Human tom = new Human(); tom.setAge(5); tom.setEyeColor(\"brown\"); tom.setHeightInInches(72); tom.setName(\"Tom Bill\"); tom.speak(); } } Human.java package JavaOOPHuman; public class Human { private String name; private int age; private int heightInInches; private String eyeColor; public Human() { } public void speak() { System.out.printf(\"Name is %s \\n\", name); System.out.printf(\"Age is %s \\n\", age); System.out.printf(\"Height is %s \\n\", heightInInches); System.out.printf(\"The eye color is %s \\n\", eyeColor); } public void eat() { System.out.println(\"Eat \"); } public void walk() { System.out.println(\"Walk \"); } public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void setHeightInInches(int heightInInches) { this.heightInInches = heightInInches; } public void setEyeColor(String eyeColor) { this.eyeColor = eyeColor; } } Java constructor Earth.java package JavaOOPHuman; public class Earth { public static void main(String[] args) { var human1 = new Human(\"Tom\", 25, 76, \"blue\"); var human2 = new Human(\"Joe\", 28, 68, \"green\"); human1.speak(); human2.speak(); } } Human.java package JavaOOPHuman; public class Human { private String name; private int age; private int heightInInches; private String eyeColor; public Human() { } public Human(String name, int age, int heightInInches, String eyeColor) { this.name = name; this.age = age; this.heightInInches = heightInInches; this.eyeColor = eyeColor; } public void speak() { System.out.printf(\"Name is %s \\n\", name); System.out.printf(\"Age is %s \\n\", age); System.out.printf(\"Height is %s \\n\", heightInInches); System.out.printf(\"The eye color is %s \\n\", eyeColor); } public void eat() { System.out.println(\"Eat \"); } public void walk() { System.out.println(\"Walk \"); } public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void setHeightInInches(int heightInInches) { this.heightInInches = heightInInches; } public void setEyeColor(String eyeColor) { this.eyeColor = eyeColor; } } "},"Application Runtime.html":{"url":"Application Runtime.html","title":"Application Runtime","keywords":"","body":"Application Runtime Application Runtime Application Runtime Zoo.java package JavaOOPAnimal; public class Zoo { public static void main(String[] args) { var animal = new Animal(12, \"M\", 23); animal.eat(); var bird1 = new Bird(); bird1.fly(); } } Animal.java package JavaOOPAnimal; public class Animal { private int age; private String gender; private int weightInLbs; public Animal(int age, String gender, int weightInLbs) { this.age = age; this.gender = gender; this.weightInLbs = weightInLbs; } public void eat() { System.out.println(\"Eating \"); } public void sleep() { System.out.println(\"Sleeping \"); } } Bird.java package JavaOOPAnimal; public class Bird { public Bird() { } public void fly() { System.out.println(\"Flying \"); } } package JavaOOPAnimal; public class Fish { public void swim() { System.out.println(\"Swimming \"); } } "},"Java concept.html":{"url":"Java concept.html","title":"Java concept","keywords":"","body":"Java concept Stack Heap Instance variable Stack The main method is the starting point in Java. We would declare variable age. int age = 12; We could define do work above main. int age = 12; do work(); There are variables inside the do work method. do work(){ int weight = 116; } There is do more work method inside do work. do work(){ int weight = 116; do moreWork(){ } } Once do work done here, it will be eliminated from the stack. Heap We would declare variable name. We would declare variable myCar. This variable is going to point to actual abject. We would use new keyword to create an object and assign it to myCar. myCar is a reference variable. It dose not contain the object. It refers to the address of memory. int age = 12; do work(); String name = \"\"; // When we here, we do not have object Car myCar; // when we here, we have object myCar = new Car; // the old car will be eliminated from heap. // this is how Java garbage collection works. myCar = new Car; Instance variable class Car{ int horsePower; Engine myEngine; } Car my2Car = new Car(); my2Car.horsePower = 120; Car my3Car = new Car(); my3Car.horsePower = 1000; Engine bigEngine = new Engine; my3Car.myEngine = bigEngine; "},"Data Structure.html":{"url":"Data Structure.html","title":"Data Structure","keywords":"","body":"Data Structure "},"Abstract Data Type.html":{"url":"Abstract Data Type.html","title":"Abstract Data Type","keywords":"","body":"Abstract Data Type Abstract data type is created using class. Abstract data type is trustworthy container capable of doing things with data. class: Counter Constructor: Counter(String str) Method: increment() getCurrentValue() toString() App.java package AbstractDataType; public class App { public static void main(String[] args) { var myCounter = new Counter(\"myCounter\"); myCounter.increment(); System.out.printf(\"%d \", myCounter.getCurrentValue()); } } Counter.java package AbstractDataType; public class Counter { private String name = null; private int value = 0; public Counter(String name) { this.name = name; } public void increment(){ value++; } public int getCurrentValue(){ return value; } public String toString(){ return name + \": \" + value; } } "},"Runing Time of An Algorithm.html":{"url":"Runing Time of An Algorithm.html","title":"Runing Time of An Algorithm","keywords":"","body":"Running Time of An Algorithm Liner = Single loop Quadratic = loop inside of loop CountEven.java package RunningTimeJava; public class CountEven { public int countEven(int element[]) { int count = 0; for (int i = 0; i GetElementFrom.java package RunningTimeJava; public class GetElementFrom { public int getElementFrom(int[] a, int index) { return a[index]; } } CountDuplicates.java package RunningTimeJava; public class CountDuplicates { public int countDuplicates(int[] items1, int[] items2) { int count = 0; for (int i = 0; i Big O notation cheat sheet "},"Data Structure Stack.html":{"url":"Data Structure Stack.html","title":"Data Structure Stack","keywords":"","body":"Data Structure Stack App.java package DataStructureStack; public class App { public static void main(String[] args) { var stack = new Stack(10); stack.push(20); stack.push(40); stack.push(60); stack.push(80); while (!stack.isEmpty()) { long value = stack.pop(); System.out.printf(\"%d \\n\", value); } } } Stack.java package DataStructureStack; public class Stack { int maxSize; long[] stackArray; int top; public Stack(int maxSize) { this.maxSize = maxSize; this.stackArray = new long[maxSize]; this.top = -1; } public void push(long j) { // check full stack if (isFull()) { System.out.println(\"this stack is full\"); } else { top++; stackArray[top] = j; } } public long pop() { if (isEmpty()) { // check empty stack System.out.println(\"the stack is empty\"); return -1; } else { int old_top = top; top--; return stackArray[old_top]; } } public long peak() { return stackArray[top]; } public boolean isEmpty() { return (top == -1); } public boolean isFull() { return (maxSize - 1 == top); } } [info] Primative Data Types We are not actually moving things from the array. We are using this pointer to point to the value. Why do you think that the 80 is the first item printed out here? The reason for that is because we are placing items on top of stack. We first put 20 and then add 40, 60 and 80. 80 is the last item placed on top of stack. Therefore, when we pop it, it will be the first item displayed here. Let's say that we would reverse the character. We would modify the JAVA program like this. App.java package DataStructureStack; public class App { public static void main(String[] args) { var stack = new Stack(10); stack.push('a'); stack.push('b'); stack.push('c'); stack.push('d'); while (!stack.isEmpty()) { char value = stack.pop(); System.out.printf(\"%c \\n\", value); } } } Stack.java package DataStructureStack; public class Stack { int maxSize; char[] stackArray; int top; public Stack(int maxSize) { this.maxSize = maxSize; this.stackArray = new char[maxSize]; this.top = -1; } public void push(char j) { // check full stack if (isFull()) { System.out.println(\"this stack is full\"); } else { top++; stackArray[top] = j; } } public char pop() { if (isEmpty()) { // check empty stack System.out.println(\"the stack is empty\"); return '0'; } else { int old_top = top; top--; return stackArray[old_top]; } } public char peak() { return stackArray[top]; } public boolean isEmpty() { return (top == -1); } public boolean isFull() { return (maxSize - 1 == top); } } We would make the Reverse Character Program better like this. ReverseString.java package DataStructureStack; public class ReverseString { public static void main(String[] args) { System.out.println(reverseString(\"Hello\")); } public static String reverseString(String str) { // the maximum stack size int stackSize = str.length(); // we make the stack var theStack = new Stack(stackSize); for (int i = 0; i "},"Data Structure Queue.html":{"url":"Data Structure Queue.html","title":"Data Structure Queue","keywords":"","body":"Data structure queue The insert() function package DataStructureQueue; public class Queue { // The index for element at the back int rearIndex; // Size of array int size; // Queue Array int[] queueArray; public Queue(int size) { this.size = size; queueArray = new int[this.size]; // There is no element in the array to be considered as the last one rearIndex = -1; } public void insert(int number) { rearIndex++; queueArray[rearIndex] = number; } public void view(){ System.out.print(\"[ \"); for (int i = 0; i package DataStructureQueue; public class App { public static void main(String[] args) { var queue = new Queue(5); queue.insert(100); queue.insert(1000); queue.insert(14); queue.insert(12); queue.insert(44); queue.view(); } } [info] Insert function The output would be [ 100 1000 14 12 44 ] The 44 is in the front side and the 100 is in the rear side. Queue package DataStructureQueue; public class Queue { // The index for element at the back private int rearIndex; // The index for element at the front private int frontIndex; // Size of array private int size; // Queue Array private int[] queueArray; // The number of array element private int numberOfElement; public Queue(int size) { this.size = size; this.queueArray = new int[this.size]; // There is no element in the array to be considered as the last one this.rearIndex = -1; this.frontIndex = 0; // There is no element in array this.numberOfElement = 0; } // Insert element from the rear of the queue public void insert(int number) { // Circular queue // When the element is greater than the array size. We would overwrite the element in the index 0 if (rearIndex == size - 1) { rearIndex = -1; } rearIndex++; queueArray[rearIndex] = number; if (!isFull()) { numberOfElement++; } } public int remove() { if (numberOfElement == 0) { System.out.println(\"The queue is empty \"); return -1; } int temp = queueArray[frontIndex]; if (frontIndex == size) { // We would set the front index to 0 in order to utilize the entire array frontIndex = 0; } else { frontIndex++; } numberOfElement--; return temp; } public int peekFront() { return queueArray[frontIndex]; } public boolean isEmpty() { return numberOfElement == 0; } public boolean isFull() { return numberOfElement == size; } public void view() { System.out.print(\"[ \"); int arrayIndex; for (int i = 0; i Queue.java package DataStructureQueue; public class App { public static void main(String[] args) { var queue = new Queue(5); queue.insert(100); queue.insert(1000); queue.insert(14); queue.insert(12); queue.insert(44); queue.remove(); queue.remove(); queue.view(); } }App.java "},"DataStructureLinkedlist.html":{"url":"DataStructureLinkedlist.html","title":"Data Structure Linked list","keywords":"","body":"Data structure linked list Create node class package DataStructureLinkedlist; public class Node { int data; Node next = null; } package DataStructureLinkedlist; public class App { public static void main(String[] args) { var nodeA = new Node(); nodeA.data = 4; var nodeB = new Node(); nodeB.data = 3; var nodeC = new Node(); nodeC.data = 7; var nodeD = new Node(); nodeD.data = 8; } } The node in memory look like this |------| |----------| |nodeA |--->| Data:|--|| | | | | 4|| |------| | |--|| | | | Next |--|| | | || | |--|| |----------| We would link the node like this Linked list package DataStructureLinkedlist; public class Node { int data; // This will allow us to link nodes together Node next = null; }Node.java package DataStructureLinkedlist; public class App { public static void main(String[] args) { var nodeA = new Node(); nodeA.data = 4; var nodeB = new Node(); nodeB.data = 3; var nodeC = new Node(); nodeC.data = 7; var nodeD = new Node(); nodeD.data = 8; nodeA.next = nodeB; nodeB.next = nodeC; nodeC.next = nodeD; System.out.println(listLength(nodeA)); System.out.println(listLength(nodeB)); } public static int listLength(Node node) { int length = 0; var currentNode = node; while (currentNode != null) { length++; currentNode = currentNode.next; } return length; } }App.java "},"SinglyLinkedList.html":{"url":"SinglyLinkedList.html","title":"SinglyLinkedList","keywords":"","body":"Singly linked list Node public class Node { public int data; public Node next; public void displayNode() { System.out.println(\"{ \" + data + \" } \"); } } InsertFirst function public void insertFirst(int data) { var node = new Node(); node.data = data; node.next = first; first = node; } InsertLast function public void insertLast(int data){ var current = first; while (current.next != null){ current = current.next; } var node = new Node(); node.data = data; current.next = node; } Singly linked list package DataStructureSinglyLikedList; public class Node { public int data; public Node next; public void displayNode() { System.out.println(\"{ \" + data + \" } \"); } }Node.java package DataStructureSinglyLikedList; public class SinglyLinkedList { private Node first; public SinglyLinkedList() { } public boolean isEmpty() { return first == null; } // We would use this function to insert element in the beginning of the list public void insertFirst(int data) { var node = new Node(); node.data = data; node.next = first; first = node; } public Node deleteFirst() { Node temp = first; first = first.next; return temp; } public void insertLast(int data) { var current = first; while (current.next != null) { current = current.next; } var node = new Node(); node.data = data; current.next = node; } public void displayList() { System.out.println(\"List from first to last \"); var current = first; while (current != null) { current.displayNode(); current = current.next; } System.out.println(); } }SinglyLinkedList.java package DataStructureSinglyLikedList; public class App { public static void main(String[] args) { var singlyLinkedList = new SinglyLinkedList(); singlyLinkedList.insertFirst(100); singlyLinkedList.insertFirst(50); singlyLinkedList.insertFirst(99); singlyLinkedList.insertFirst(88); singlyLinkedList.insertLast(1000); singlyLinkedList.deleteFirst(); singlyLinkedList.deleteFirst(); singlyLinkedList.displayList(); } }App.java "}}